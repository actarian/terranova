{"version":3,"sources":["src/js/image/image.service.worker.js","../../../src/js/image/image.service.worker.js"],"names":["f","define","amd","ImageServiceWorkerEvent","controllers","resize","src","blob","size","self","createImageBitmap","OffscreenCanvas","sendMessage","then","img","width","height","canvas","ctx","getContext","drawImage","convertToBlob","type","quality","resizedBlob","data","postMessage","addEventListener","event","id","_ref","_ref$defaultSize","defaultSize","_ref$emitDelay","emitDelay","_ref$onProgress","onProgress","_ref$onComplete","onComplete","_ref$onError","onError","options","mode","fetch","AbortController","controller","signal","response","Response","ReadableStream","body","headers","status","contentLength","get","progress","Progress","reader","getReader","stream","start","push","read","_ref2","done","value","close","next","enqueue","catch","err","error","console","log","request","XMLHttpRequest","open","responseType","withCredentials","onload","this","onprogress","onerror","send","abort","length","eventStart","loaded","parseInt","prototype","chunk","chunkLength","Date","now","total"],"mappings":"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","file":"docs\\js\\workers\\image.service.worker.min.js","sourcesContent":[null,"\r\nconst ImageServiceWorkerEvent = {\r\n\tProgress: 'progress',\r\n\tComplete: 'complete',\r\n};\r\n\r\nconst controllers = {};\r\n\r\nfunction resize(src, blob, size) {\r\n\tif (!self.createImageBitmap || !self.OffscreenCanvas) {\r\n\t\treturn sendMessage(ImageServiceWorkerEvent.Complete, src, blob);\r\n\t}\r\n\tself.createImageBitmap(blob).then(function(img) {\r\n\t\tconst MAX_WIDTH = 320;\r\n\t\tconst MAX_HEIGHT = 240;\r\n\t\tlet width = img.width;\r\n\t\tlet height = img.height;\r\n\t\tif (width > height) {\r\n\t\t\tif (width > MAX_WIDTH) {\r\n\t\t\t\theight *= MAX_WIDTH / width;\r\n\t\t\t\twidth = MAX_WIDTH;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (height > MAX_HEIGHT) {\r\n\t\t\t\twidth *= MAX_HEIGHT / height;\r\n\t\t\t\theight = MAX_HEIGHT;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst canvas = new OffscreenCanvas(width, height);\r\n\t\tconst ctx = canvas.getContext('2d');\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\t\tctx.drawImage(img, 0, 0, width, height);\r\n\t\tcanvas.convertToBlob({ type: 'image/jpeg', quality: 0.9 }).then(function(resizedBlob) {\r\n\t\t\tsendMessage(ImageServiceWorkerEvent.Complete, src, resizedBlob);\r\n\t\t});\r\n\t});\r\n}\r\n\r\nfunction sendMessage(type, src, data) {\r\n\tself.postMessage({\r\n\t\ttype: type,\r\n\t\tsrc: src,\r\n\t\tdata: data\r\n\t});\r\n}\r\n\r\nself.addEventListener('message', function(event) {\r\n\tconst id = event.data.id;\r\n\tconst src = event.data.src;\r\n\tconst size = event.data.size;\r\n\tif (id && !src) {\r\n\t\tconst controller = controllers[id];\r\n\t\tif (controller) {\r\n\t\t\t// console.log('Aborting', id);\r\n\t\t\tcontroller.abort();\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tconst options = {\r\n\t\tmode: 'cors', // no-cors, *cors, same-origin\r\n\t};\r\n\tif (typeof fetch === 'function') {\r\n\t\tif (self.AbortController) {\r\n\t\t\tconst controller = new AbortController();\r\n\t\t\toptions.signal = controller.signal;\r\n\t\t\tcontrollers[id] = controller;\r\n\t\t\t// console.log('AbortController', id);\r\n\t\t}\r\n\t\tconst response = fetch(src, options)\r\n\t\t\t.then(fetchProgress({\r\n\t\t\t\t// implement onProgress method\r\n\t\t\t\tonProgress(event) {\r\n\t\t\t\t\t// console.log('ImageServiceWorker', event.loaded, event.total);\r\n\t\t\t\t\tsendMessage(ImageServiceWorkerEvent.Progress, src, event);\r\n\t\t\t\t},\r\n\t\t\t}))\r\n\t\t\t.then(function(response) {\r\n\t\t\t\treturn response.blob();\r\n\t\t\t}, function(error) {\r\n\t\t\t\tconsole.log(error);\r\n\t\t\t})\r\n\t\t\t.then(function(blob) {\r\n\t\t\t\tdelete controllers[id];\r\n\t\t\t\tif (typeof size === 'object') {\r\n\t\t\t\t\tresize(src, blob, size);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsendMessage(ImageServiceWorkerEvent.Complete, src, blob);\r\n\t\t\t\t}\r\n\t\t\t}, function(error) {\r\n\t\t\t\tconsole.log(error);\r\n\t\t\t});\r\n\t} else {\r\n\t\tconst request = new XMLHttpRequest();\r\n\t\trequest.open('GET', src, true);\r\n\t\trequest.responseType = 'blob';\r\n\t\trequest.withCredentials = true;\r\n\t\trequest.onload = function() {\r\n\t\t\tif (request.status < 300) {\r\n\t\t\t\tif (typeof size === 'object') {\r\n\t\t\t\t\tresize(src, this.response, size);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsendMessage(ImageServiceWorkerEvent.Complete, src, this.response);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// new Error('Image didn\\'t load successfully; error code:' + request.statusText);\r\n\t\t\t}\r\n\t\t};\r\n\t\trequest.onprogress = function(event) {\r\n\t\t\t// console.log('ImageServiceWorker', event.loaded, event.total);\r\n\t\t\tsendMessage(ImageServiceWorkerEvent.Progress, src, event);\r\n\t\t}\r\n\t\trequest.onerror = function() {\r\n\t\t\t// new Error('There was a network error.');\r\n\t\t};\r\n\t\trequest.send();\r\n\t}\r\n});\r\n\r\n/*\r\nself.addEventListener('message', function(event) {\r\n\t// console.log(event);\r\n\tconst src = event.data;\r\n\tconst response = fetch(src).then(function(response) {\r\n\t\treturn response.blob();\r\n\t}).then(function(blob) {\r\n\t\t// Send the image data to the UI thread!\r\n\t\tself.postMessage({\r\n\t\t\tsrc: src,\r\n\t\t\tblob: blob,\r\n\t\t});\r\n\t});\r\n});\r\n*/\r\n\r\nfunction isFetchProgressSupported() {\r\n\treturn (\r\n\t\ttypeof Response !== 'undefined' && typeof ReadableStream !== 'undefined'\r\n\t);\r\n}\r\n\r\nfunction fetchProgress({\r\n\tdefaultSize = 0,\r\n\temitDelay = 10,\r\n\tonProgress = () => null,\r\n\tonComplete = () => null,\r\n\tonError = () => null,\r\n}) {\r\n\treturn function FetchProgress(response) {\r\n\t\tif (!isFetchProgressSupported()) {\r\n\t\t\treturn response;\r\n\t\t}\r\n\t\tconst { body, headers, status } = response;\r\n\t\tconst contentLength = headers.get('content-length') || defaultSize;\r\n\t\tconst progress = new Progress(contentLength, emitDelay);\r\n\t\tconst reader = body.getReader();\r\n\t\tconst stream = new ReadableStream({\r\n\t\t\tstart(controller) {\r\n\t\t\t\tfunction push() {\r\n\t\t\t\t\treader\r\n\t\t\t\t\t\t.read()\r\n\t\t\t\t\t\t.then(({ done, value }) => {\r\n\t\t\t\t\t\t\tif (done) {\r\n\t\t\t\t\t\t\t\tonComplete({});\r\n\t\t\t\t\t\t\t\tcontroller.close();\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\t\t\tprogress.next(\r\n\t\t\t\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\t\t\t\tonProgress\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcontroller.enqueue(value);\r\n\t\t\t\t\t\t\tpush();\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.catch((err) => {\r\n\t\t\t\t\t\t\tonError(err);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tpush();\r\n\t\t\t},\r\n\t\t});\r\n\t\treturn new Response(stream, { headers, status });\r\n\t};\r\n}\r\n\r\nclass Progress {\r\n\r\n\tconstructor(length, emitDelay = 1000) {\r\n\t\tthis.eventStart = 0;\r\n\t\tthis.loaded = 0;\r\n\t\tthis.length = parseInt(length, 10) || 0;\r\n\t\tthis.emitDelay = emitDelay;\r\n\t}\r\n\r\n\tnext(chunk, onProgress) {\r\n\t\tconst chunkLength = chunk.length;\r\n\t\tthis.loaded += chunkLength;\r\n\t\tthis.eventStart = this.eventStart || Date.now();\r\n\t\tif (this.length >= this.loaded || Date.now() - this.eventStart > this.emitDelay) {\r\n\t\t\tthis.eventStart = Date.now();\r\n\t\t\tconst progress = {\r\n\t\t\t\ttotal: this.length,\r\n\t\t\t\tloaded: this.loaded,\r\n\t\t\t};\r\n\t\t\tonProgress(progress);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/*\r\nfunction fetchProgress__(response, onProgress) {\r\n\tconst reader = response.body.getReader();\r\n\t// Step 2: get total length\r\n\tconst contentLength = +response.headers.get('Content-Length');\r\n\t// Step 3: read the data\r\n\tlet receivedLength = 0; // received that many bytes at the moment\r\n\tlet chunks = []; // array of received binary chunks (comprises the body)\r\n\twhile (true) {\r\n\t\tconst { done, value } = await reader.read();\r\n\t\tif (done) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tchunks.push(value);\r\n\t\treceivedLength += value.length;\r\n\t\tif (typeof onProgress === 'function') {\r\n\t\t\tonProgress(receivedLength, contentLength);\r\n\t\t}\r\n\t\tconsole.log(`ImageServiceWorker.onProgress ${receivedLength} of ${contentLength}`)\r\n\t}\r\n\t// Step 4: concatenate chunks into single Uint8Array\r\n\tlet chunksAll = new Uint8Array(receivedLength); // (4.1)\r\n\tlet position = 0;\r\n\tfor (let chunk of chunks) {\r\n\t\tchunksAll.set(chunk, position); // (4.2)\r\n\t\tposition += chunk.length;\r\n\t}\r\n\t// Step 5: decode into a string\r\n\tlet result = new TextDecoder(\"utf-8\").decode(chunksAll);\r\n\t// We're done!\r\n\tlet commits = JSON.parse(result);\r\n}\r\n*/\r\n"]}